\documentclass[submission]{gmp2017}
%\documentclass{gmp2017}

\title{Parallel Quadtree Construction on Collections of Objects}

% Put your submission number here.
% This number will appear instead of authors and affiliations if the
% class option "submission" is active.
\SubNumber{142}

% Put the author names here.
% Use the second argument as a reference to the list of affiliations.
% No authors and affiliations will appear if the class option "submission"
% is active.
\author{John Edwards}{1}
\author{Nathan Vollmer}{1}
\author{Nicholas Harrison}{1}

% Put the affiliations of the authors here.
\affiliation{1}{Department of Informatics and Computer Science, Idaho State University, USA}

\input{common}

\usepackage[inline]{showlabels}

%-------------------------------------------------------------------------
\begin{document}

%\teaser{
%  \subfloat[][]{
%    \label{fig:gears1}
%    \begin{tikzpicture}
%      \node[anchor=south west,inner sep=0] at (0,0) {
%        \begin{tabular}[b]{c}
%          \includegraphics[height=0.8in]{gears-far1.png} \\
%          \includegraphics[height=0.8in]{gears-close1.png}
%        \end{tabular}
%      };
%      \draw[black,thick] (1.4,3.2) rectangle (2.0,3.6);
%      \draw[black,dashed] (1.4,3.6) -- (0.22,2.15);
%      \draw[black,dashed] (2.0,3.6) -- (2.95,2.15);
%      \draw[black,thick] (0.22,0.1) rectangle (2.95,2.15);
%    \end{tikzpicture}
%  }
%  \subfloat[][]{
%    \label{fig:gears}
%    \begin{tikzpicture}
%      \node[anchor=south west,inner sep=0] at (0,0) {
%        \begin{tabular}[b]{c}
%          \includegraphics[height=0.8in]{gears-far4.png} \\
%          \includegraphics[height=0.8in]{gears-close4.png}
%        \end{tabular}
%      };
%      \draw[black,thick] (1.3,3.1) rectangle (1.9,3.5);
%      \draw[black,dashed] (1.3,3.5) -- (0.22,2.15);
%      \draw[black,dashed] (1.9,3.5) -- (2.92,2.15);
%      \draw[black,thick] (0.22,0.1) rectangle (2.92,2.15);
%    \end{tikzpicture}
%  }
%  \hspace{3mm}
%  \subfloat[][]{
%    \label{fig:knife}
%    \includegraphics[trim=4cm 0cm 4cm 2.5cm, clip=true, height=1.4in]
%                    {knife-above/slice-00000.png}
%  }
%  \subfloat[][]{
%    \label{fig:knife2}
%    \includegraphics[trim=2mm 0cm 2mm 2cm, clip=true, height=1.4in]
%                    {knife-above/slice-00110.png}
%  }
%  \caption{Two example applications of the \red{approximated} generalized Voronoi diagram (GVD) computed by our novel, adaptive algorithm. Previous GVD methods require a gridded space of $2^{24}$ (gears dataset) and $2^{36}$ (knives dataset) voxels to resolve the closely spaced objects.
%    \protect\subref{fig:gears1} Two gears with regions of very tight spacing.
%    \protect\subref{fig:gears} The GVD of the gears model.  The surface is colored red in areas of very close tolerance.
%    \protect\subref{fig:knife} Three butter knives in a wood block.  To animate removal of the knives without intersecting the block requires extreme care because of close mesh spacing.
%    \protect\subref{fig:knife2} Intersection-free motion is guaranteed by computing motion vectors based on the GVD and allowing motion only within a Voronoi cell.
%  }
%  \label{fig:teaser}
%}
%
\maketitle

\begin{abstract}
We present a parallel quadtree algorithm that resolves between geometric objects. The quadtree has the property that no quadtree cell intersects more than one labeled object. Previous parallel algorithms either spawn kernels hierarchically, separate points only, or make no hard guarantees of object separation. Our algorithm runs in \red{complexity?} in the average case and has excellent results in practice. We demonstrate with results on 2D and 3D datasets.

%   Leave one blank line after the abstract, 
%   then add the subject categories according to the ACM Classification Index 
%   (see http://www.acm.org/class/1998/).

%\begin{classification} % according to http://www.acm.org/class/1998/
%  \CCScat{I.3.5}{Computer Graphics}{Computational Geometry and Object Modeling}{Boundary representations}
%  \CCScat{I.3.6}{Computer Graphics}{Methodology and Techniques}{Graphics data structures and data types}
%  %\CCScat{Computer Graphics}{I.3.3}{Picture/Image Generation}{Line and curve generation}
%\end{classification}

\end{abstract}

%-------------------------------------------------------------------------
% Body
%-------------------------------------------------------------------------

%-------------------------------------------------------------------------------
% introduction
%-------------------------------------------------------------------------------
\section{Introduction}
\label{sec:intro}
Constructing quadtrees on objects in an important task with applications to collision detection, distance fields, robot navigation, object description, and other applications. Quadtrees built on objects most often model the objects themselves, providing a space-efficient representation of arbitrarily complex objects. Our work however, centers on using quadtrees to separate, or resolve, collections of closely spaced objects. Using a quadtree, we can model the space between objects, the first step in constructing distance fields, detecting collisions, and computing the generalized Voronoi diagram. Modeling inter-object spacing is computationally straightforward when inter-object spacing is large compared to the world bounding box. Approaches typically involve a uniform grid of the space, which leads to efficient computation that often uses graphics processors.

Difficulties arise when spacing between objects is small relative to the size of the domain. An approach using a uniform grid would have excessive memory requirements in order to resolve between objects. \red{What does ``resolve'' mean?} In these cases, teh uniformly sized grid cell must be small enough to fit between objects at every location in the domain. To our knowledge, only one algorithm \cite{edwards2015approximating} computes an adaptive data structure that fully resolves between objects without using unreasonable amounts of memory.

We present an algorithm that builds a quadtree on arbitrarily spaced objects in parallel. This work extends the work done by Edwards et al \cite{edwards2015approximating} by computing the quadtree in parallel with an algorithm targeted for the GPU. Our algorithm performs an order of magnitude faster than the previous work and will be an excellent base for later distance transform and generalized Voronoi diagram computation.

Our algorithm has three steps:

\begin{enumerate}
\item Construct an quadtree on object vertices using Karras' algorithm \cite{karras2012maximizing}
\item Detect quadtree cells that intersect more than one object, which we call ``conflict cells'' (contribution)
\item Subdivide conflict cells to resolve objects (contribution)
\end{enumerate}

Each step is done in parallel either on vertices, quadtree cells or object facets.

%-------------------------------------------------------------------------------
% Related work
%-------------------------------------------------------------------------------
\section{Related work}
In an early work, Lavender \etal \shortcite{lavender1992voronoi} define and compute quadtrees over a set of solid models. \red{Boada \etal \shortcite{boada2002voronoi,boada2008approximations} use an adaptive approach to GVD computation, but their algorithm is restricted to GVDs with connected regions and is inefficient for polyhedral objects with many facets.  Two other works are adaptive \cite{teichmann1997polygonal,vleugels1998approximating} but are computationally expensive and are restricted to convex sites.}

% JME: note that in the Bastos work, ``reconstruction'' is reconstruction
% of the surface from the quadtree at rendering time.
Two seminal works build octrees on objects in order to compute the Adaptive Distance Field (ADF) on octree vertices.  Strain~\shortcite{strain1999fast} fully resolves the quadtree everywhere on the object surface, and Frisken \etal~\shortcite{frisken2000adaptively} resolve the quadtree fully only in areas of small local feature size.  Both approaches are designed to retain features of a single object rather than resolving between multiple objects, as is required for GVD computation. Many recent works on fast quadtree construction using the GPU are limited to point sites \cite{bedorf2012sparse,karras2012maximizing,zhou2011data}. Kim and Liu's work~\shortcite{kim2014exact} is similar, computing the quadtree on the barycenters of triangles, giving an approximation of an object-resolving quadtree. Most quadtree approaches that support surfaces \cite{baert2013out,crassin2009gigavoxels,laine2011efficient,lefebvre2007compressed} are designed for efficient rendering, and actual construction of the quadtree is implemented on the CPU.

Two works \cite{bastos2008gpu,park2010cuda} implement Adaptive Distance Fields in parallel on quadtrees but building the quadtree itself is done sequentially.  Yin \etal~\shortcite{yin2011fast} compute the octree entirely on the GPU using a bottom-up approach by initially subdividing into a complete quadtree, resulting in memory usage that is no better than using a uniform grid. We have found no GPU quadtree construction method that is fully adaptive and can resolve between objects.

%-----------------------------------------------------------
% Build quadtree
%-----------------------------------------------------------
\section{Algorithm}
\label{sec:algorithm}

We refer to quadtree leaf cells that intersect two or more objects as ``conflict cells.'' A necessary and sufficient condition for a quadtree to resolve objects is to have no conflict cells. Our approach to computing such a quadtree is to first detexct conflict cells in parallel and then resolve them.

Our algorithm proceeds in three main steps:

\begin{tightenumerate}
\item Build initial octree on vertices $V$ \cite{karras2012maximizing}
\item Detect conflict cells
  \begin{tightenumerate}
  \item Build bounding cells (BCells) array (Figure \ref{fig:data-structures-1})
  \item Sort BCells array (Figure \ref{fig:data-structures-2})
  \item Index BCells with octree data structure (Figure \ref{fig:data-structures-3})
  \item Find facets that intersect each leaf cell
  \end{tightenumerate}
\item Resolve conflict cells
  \begin{tightenumerate}
  \item Compute sample points $S$
  \item Build new octree on $V \cup S$
  \end{tightenumerate}
\item Iterate
\end{tightenumerate}

Steps 1 and 2 are independent of dimension, and so our descriptions will use dimension-independent terms. In this paper, step 3 is described in 2D, with a 3D extension left to future work.

\subsection{Build initial octree}
Our first step is to build an octree on the vertices using Karras' algorithm \cite{karras2012maximizing}. This step gives us our first approximation to our final octree.

\subsection{Detect conflict cells}

Let the ``quadtree address'' refer to the unique ID of a quadtree cell $C$ found by concatenating the local addresses of its ancestors from Root to $C$. The address of the root cell is a special case and is defined as $R$. Figure \ref{fig:conflict-find-4} shows the address of each leaf cell in a quadtree.

We define a bounding cell (BCell) to be the smallest internal quadtree node which entirely contains a given facet. Given a facet defined by $n$ endpoints $P=\{p_1, p_2, \dots, p_n\}$, the quadtree address of the BCell is the longest common prefix of the Morton codes of the points in $P$. Figure \ref{fig:scc-sort-1} gives the addresses of the BCells of the facets in figure \ref{fig:conflict-find-4}.

We begin by constructing an array of BCells (see figure \ref{fig:data-structures-1}), which is done in parallel over all facets. Each facet $f$ computes the longest common prefix of its vertices and stores the result in \texttt{BCells[$f$].Cell\_ID}.

Next we sort the \texttt{BCells} array on the \texttt{Cell\_ID} field using a parallel radix lexicographical sort (Figure \ref{fig:data-structures-2}). \texttt{BCells} array construction and sorting is done in parallel with the initial Karras octree construction.

\begin{figure}
  \centering
  \subfloat[][]{
    \label{fig:conflict-find-1}
    \includegraphics[width=0.22\columnwidth]{conflict-find-1.pdf} } \hfill
  \subfloat[][]{
    \label{fig:conflict-find-2}
    \includegraphics[width=0.22\columnwidth]{conflict-find-2.pdf} } \hfill
  \subfloat[][]{
    \label{fig:conflict-find-4}
    \includegraphics[width=0.22\columnwidth]{conflict-find-4.pdf} } \hfill
  \subfloat[][]{
    \label{fig:conflict-find-5}
    \includegraphics[width=0.22\columnwidth]{conflict-find-5.pdf} } \\
  \subfloat[][]{
    \label{fig:conflict-find-6}
    \includegraphics[width=0.22\columnwidth]{conflict-find-6.pdf} } \hfill
  \subfloat[][]{
    \label{fig:data-structures-1}
    \includegraphics[width=0.22\columnwidth]{data-structures-1.pdf} } \hfill
  \subfloat[][]{
    \label{fig:data-structures-2}
    \includegraphics[width=0.22\columnwidth]{data-structures-2.pdf} } \hfill
  \subfloat[][]{
    \label{fig:data-structures-3}
    \includegraphics[width=0.22\columnwidth]{data-structures-3.pdf} }
  \caption{
    \protect\subref{fig:conflict-find-1} We have three objects, blue, red, and orange with facets labeled A-I.
    \protect\subref{fig:conflict-find-2} We construct an initial quadtree on the vertices using Karras' algorithm.
    \protect\subref{fig:conflict-find-4} We then compute the smallest common cell (SCC) for each facet. These pairs are given in figure \protect\subref{fig:scc-sort-1}.
    \protect\subref{fig:conflict-find-5} Conflict cells, which intersect more than one object, are highlighted.
    \protect\subref{fig:conflict-find-6} The new quadtree after conflict resolution.
    \protect\subref{fig:data-structures-1} The bounding cells (BCells) are stored in an array initially sorted on facet index (letters are used here for clarity).
    \protect\subref{fig:data-structures-2} We sort the BCells array using a parallel radix sort on BCell address for fast indexed access.
    \protect\subref{fig:data-structures-3} We then, in parallel on each element of BCells, store the index of the quadtree cell corresponding to the Cell\_ID and, if the previous element in the BCells array does not have an identical Cell\_ID, store the BCell index in the quadtree Facets field. \red{I don't think we need \texttt{BCells.Cell\_idx}. I don't use it in the algorithm description.}
  }
  \label{fig:conflict-find}
\end{figure}

\begin{figure}
  \label{fig:scc-sort}
\end{figure}

Then we use the \texttt{BCells} array and octree data structure to find the conflict cells using algorithm \ref{alg:find-conflict-cells}. We process each leaf cell $L$ in parallel. We set $L$'s color to $-1$ (uninitialized). We then investigate each ancestor $A$ of $L$. We find the ancestors using the \texttt{Parent} field in the octree data structure. Using the \texttt{Facets} field, we find the first of possibly multiple facets bounded by $A$. The first facet's index is found using \texttt{BCells[Quadtree[$A$].Facets].Facet\_idx}. Any facet $f$ for which $A$ is the bounding cell could potentially intersect the leaf cell $L$. We test for intersection between $f$ and $L$ and \red{continue on here...}.

\algorithmspace
\begin{algorithm}
  \DontPrintSemicolon
  \LinesNumbered
  \KwIn{VertexQuadtree}
  \BlankLine
  \ForPar{leaf cell $L$}{
    $L$.color = -1\;
    \ForEach{cell $A$ in \directAncestors{$L$}}{
      id := compute\_cell\_index($A$)\;
      \ForEach{cell2facet in identical elements of cells2facets[id]}{
        $f$ := cell2facet.facet\;
        \If{$f$ intersects $L$}{
          \If{$L$.color == -1} {
            \tcp{First facet found}
            \tcp{that intersects $L$}
            $L$.color = $f$.color\;
            $L$.facet[0] = $f$\;
          }
          \ElseIf{$L$.color != $f$.color} {
            \tcp{Cell $L$ is ambiguous}
            $L$.color = -2\;
            $L$.facet[1] = $f$\;
          }
        }
      }
    }
  } \label{alg:quadtree_intersections_end}
\caption{FIND\_CONFLICT\_CELLS}
\label{alg:find-conflict-cells}
\end{algorithm}
\algorithmspace

\subsection{Resolve conflict cells}

%\begin{adjustbox}{valign=t}
\begin{figure}
  \centering
  \subfloat[][]{
    \label{fig:conflict-resolution-x}
    \includegraphics[width=0.24\columnwidth]{conflict-resolution-x.pdf} }
  \subfloat[][]{
    \label{fig:conflict-resolution-even}
    \includegraphics[width=0.24\columnwidth]{conflict-resolution-even.pdf} }
  \subfloat[][]{
    \label{fig:conflict-resolution-all}
    \includegraphics[width=0.24\columnwidth]{conflict-resolution-all.pdf} }
  \subfloat[][]{
    \label{fig:conflict-resolution-octree}
    \includegraphics[width=0.24\columnwidth]{conflict-resolution-octree.pdf} } \\
  \subfloat[][]{
    \label{fig:conflict-resolution-adjacent-even}
    \includegraphics[width=0.24\columnwidth]{conflict-resolution-adjacent-even.pdf} }
  \subfloat[][]{
    \label{fig:conflict-resolution-adjacent-all}
    \includegraphics[width=0.24\columnwidth]{conflict-resolution-adjacent-all.pdf} }
  \caption{
    \protect\subref{fig:conflict-resolution-x} A conflict cell with two lines from different objects.
    \protect\subref{fig:conflict-resolution-even} Fitting boxes such that any box intersecting both lines contains at least one sample (red dots).
    \protect\subref{fig:conflict-resolution-even} Fitting boxes such that any box intersecting both lines contains at least two samples. This ensures that an quadtree built from the samples using Karras' algorithm (panel \protect\subref{fig:conflict-resolution-octree}) will have no leaf cells that intersect both lines, ensuring that the new quadtree is locally free of conflict cells.
  }
  \label{fig:conflict-resolution}
\end{figure}
%    \end{adjustbox}


%\begin{equation}
%\label{eqn:p}
%p(s) = p = p_0 + su
%\end{equation}
%\begin{equation}
%\label{eqn:q}
%q(s) = q = q_0 + tv
%\end{equation}
%\begin{equation}
%\label{eqn:a_}
%a(s) = a = |p^x-q^x| = |p^y-q^y|
%\end{equation}

A conflict cell is a quadtree cell that intersects at least two different objects. To resolve a conflict cell $c$, we consider pairs of lines of differing labels that intersect $c$. Figure \ref{fig:conflict-resolution-x} shows two lines

\begin{align}
q(t) &= q = q_0 + tv \label{eqn:q} \\
r(f) &= r = r_0 + fw \label{eqn:r}
\end{align}
along with a line
\begin{align}
p(s) &= p = p_0 + su \label{eqn:p}
\end{align}
that bisects $q$ and $r$. Our strategy will be to sample points $P$ on $p(s)$ (figure \ref{fig:conflict-resolution-octree}) such that an quadtree built on $V \cup P$ will completely ``separate'' $q$ and $r$, i.e., no descendent cell of $c$ will intersect both $q$ and $r$. We do this by ensuring that $P$ is sampled such that every box that intersects both $q$ and $r$ also intersects at least two points in $P$. Because Karras' algorithm guarantees that every leaf cell intersects at most one point, we know that no leaf cell will intersect $q$ and $r$ and thus no leaf cell will be a conflict cell. We will find a series of boxes such that each box's left-most intersection with $p(s)$ is a sample point meeting the above criterion.

We consider only cases where the slope of $p$ is in the range $0 \le m \le 1$. All other cases can be transformed to this case using rotation and reflection. We begin by fitting the smallest box centered on a point $p$ that intersects both $q$ and $r$. We break the problem into two cases: the \textit{opposite} case (see Figure \ref{fig:conflict-resolution-even}) is where $w^y > 0$, so each box intersects $q$ and $r$ at its top-left and bottom-right corners, respectively. The \textit{adjacent} case (see Figure \ref{fig:conflict-resolution-adjacent-even}) is where $w^y < 0$, so the line intersections are adjacent at the top-left and bottom-left corners of the box.

\subsubsection{Finding $a(s)$ -- \textit{opposite} case}

Given a point $p(s)$, we wish to find $a=a(s)$, which will give us the starting $x$ coordinate for the next box. Consider the top-left corner of the box $q(t(s))=q(t)$ and the bottom-right corner $r(f(s))=r(f)$.

Because $p^x(s)=q^x(t)$,
\begin{equation}
t = \frac{p^x(s)-q_0^x}{v^x} = \frac{p_x^x-q_0^x+su^x}{v^x} \label{eqn:t}
\end{equation}
Because our boxes are square,
\begin{equation}
r(f) = r_0+fw = q_0+tv+a\begin{bmatrix}1\\-1\end{bmatrix} \label{eqn:ro}
\end{equation}
From \eqref{eqn:ro},
\begin{align}
f &= \frac{1}{w^y}(q_0^y+tv^y-a-r_0^y) \label{eqn:f} \\
a &= r_0^x+fw^x-q_0^x-tv^x \label{eqn:a1o}
\end{align}
Substituting equations \eqref{eqn:t} and \eqref{eqn:f} into equation \eqref{eqn:a1o} and solving for $a$,
\begin{equation}
a(s) = \hat{\alpha}_o s + \hat{\beta}_o \label{eqn:ao}
\end{equation}
where
\begin{equation}
\hat{\alpha}_o = \frac{u^x|w \times v|}{v^x(w^x+w^y)}
\end{equation}
and
\begin{equation}
\hat{\beta}_o = \frac{|w \times v|(p_0^x-q_0^x) + v^x(|r_0 \times w| + |w \times q_0|)}{v^x(w^x+w^y)}
\end{equation}

\subsubsection{Finding $a(s)$ -- \textit{adjacent} case}

Consider the top-left corner of the box $q(t(s))=q(t)$ and the bottom-left corner $r(f(s))=r(f)$. $r(f)$ is now defined as
\begin{equation}
r(f) = r_0+fw = q_0+tv+a\begin{bmatrix}0\\-1\end{bmatrix} \label{eqn:ra}
\end{equation}
Equations \eqref{eqn:t} and \eqref{eqn:f} remain the same while \eqref{eqn:a1o} becomes
\begin{equation}
0 = r_0^x+fw^x-q_0^x-tv^x \label{eqn:a1a}
\end{equation}
Substituting equations \eqref{eqn:t} and \eqref{eqn:f} into equation \eqref{eqn:a1a} and solving for $a$,
\begin{equation}
a(s) = \hat{\alpha}_a s + \hat{\beta}_a \label{eqn:aa}
\end{equation}
where
\begin{equation}
\hat{\alpha}_a = \frac{u^x}{v^xw^x}
\end{equation}
and
\begin{equation}
\hat{\beta}_a = \frac{w^x(p_0^x-q_0^x)+|w \times q_0| + |r_0 \times w|}{w^x}
\end{equation}


%
%
%Because $p^x(s)=q^x(t)$,
%\begin{equation}
%t = \frac{p^x(s)-q_0^x}{v^x} = \frac{p_x^x-q_0^x+su^x}{v^x} \label{eqn:t}
%\end{equation}
%Because our boxes are square,
%\begin{equation}
%r(f) = r_0+fw = q_0+tv+a
%\begin{bmatrix}
%1\\-1
%\end{bmatrix}
%\label{eqn:r}
%\end{equation}
%From \eqref{eqn:r},
%\begin{align}
%f &= \frac{1}{w^y}(q_0^y+tv^y-a-r_0^y) \label{eqn:f} \\
%a &= r_0^x+fw^x-q_0^x-tv^x \label{eqn:a1}
%\end{align}
%Substituting equations \eqref{eqn:t} and \eqref{eqn:f} into equation \eqref{eqn:a1} and solving for $a$,
%\begin{equation}
%a = \alpha s + \beta
%\end{equation}
%where
%\begin{equation}
%\alpha = \frac{u^x|w \times v|}{v^x(w^x+w^y)}
%\end{equation}
%and
%\begin{equation}
%\beta = \frac{|w \times v|(p_0^x-q_0^x) + v^x(|r_0 \times w| + |w \times q_0|)}{v^x(w^x+w^y)}
%\end{equation}
%
%Consider a box with edge length $a_0$ centered on a point $p_0 \in p$. We first find $p$, which is the line that is equidistant from $q$ and $r$ along the diagonal vector $\gamma = (1, -1)$. Given some point $q(t)$,
%\begin{equation}
%q_0+tv + \lambda\gamma = r_0+fw \\
%\end{equation}
%Solving for $\lambda$,
%\begin{align}
%f &= \frac{1}{w^y}(q_0^y+tv^x-\lambda-r_0^y) \\
%\lambda &= r_0^x + fw^x-q_0^x-tv^x \\
%        &= r_0^x+\frac{w^x}{w^y}(q_0^y+tv^y-\lambda-r_0^y) - q_0^x-tv^x \\
%        &= \frac{1}{w^x+w^y}(r_0^xw^y+q_0^yw^x-r_0^yw^x-q_0^xw^y+t(v^yw^x-v^xw^y)
%\end{align}
%The vector $u = p - p_0$. We obtain $p$ from $q(0)$, by finding $\lambda/2$.
%\begin{align}
%p = q(0) + \frac{\lambda}{2}\gamma
%\end{align}
%We get $p_0$ by finding the intersection between the two lines. If they are parallel then we find two points $p$ using $q(0)$ and $q(1)$.
%
%To find $a$,
%\begin{align} 
%p^x-\frac{a}{2} &= q^x \\
%p^y+\frac{a}{2} &= q^y
%\end{align}
%Substituting equation \eqref{eqn:q},
%\begin{align} 
%t = \frac{p^x-a/2-q_0^x}{v^x} \\
%t = \frac{p^y+a/2-q_0^y}{v^y}
%\end{align}
%which leads to
%\begin{align} 
%\frac{p^x-a/2-q_0^x}{v^x} &= \frac{p^y+a/2-q_0^y}{v^y}
%\end{align}
%Solving for $a$,
%\begin{align}
%\label{eqn:plain_a}
%a &= \frac{2(p^xv^y-q_0^xv^y-p^yv^x+q_0^yv^x)}{v^x+v^y}
%\end{align}
%$a$ is a parametric function in $s$, so using equations \eqref{eqn:plain_a} and \eqref{eqn:p},
%\begin{align}
%a(s) &= \frac{2((p_0^x+su^x)v^y-q_0^xv^y-(p_0^y+su^y)v^x+q_0^yv^x)}{v^x+v^y} \\
%     &= s\frac{2(u^xv^y-u^yv^x)}{v^x+v^y} + \frac{2(p_0^xv^y-q_0^xv^y-p_0^yv^x+q_0^yv^x)}{v^x+v^y} \label{eqn:a}
%\end{align}
%Figure \ref{fig:conflict-resolution-even} shows that we will find a series of points $P=p(s_i)$ such that
%\begin{equation}
%p^x(s_i) = p^x(s_{i-2})+a(s_{i-2}) \label{eqn:p_s}
%\end{equation}
%Using equations \eqref{eqn:p}, \eqref{eqn:a} and \eqref{eqn:p_s},
%\begin{align}
%p_0^x+s_iu^x = p_0^x+s_{i-2}u^x+s_{i-2}\frac{2(u^xv^y-u^yv^x)}{v^x+v^y} + \frac{2(p_0^xv^y-q_0^xv^y-p_0^yv^x+q_0^yv^x)}{v^x+v^y}
%\end{align}
%Solving for $s_i$,
%\begin{equation}
%\label{eqn:si_rec}
%s_i = s_{i-2}\alpha + \beta
%\end{equation}
%where
%\begin{align}
%%\alpha &= \frac{u^xv^x+3u^xv^y-2u^yv^x}{u^x(v^x+v^y)}
%\alpha &= 1+\frac{2(u^xv^y-u^yv^x)}{u^x(v^x+v^y)} \\
%\beta &= \frac{2(p_0^xv^y-q_0^xv^y-p_0^yv^x+q_0^yv^x)}{u^x(v^x+v^y)}
%\end{align}

\subsubsection{Sampling}
In both the \textit{opposite} and the \textit{adjacent} cases, $a(s)$ is of the form $a(s) = \hat{\alpha} s + \hat{\beta}$. We now use $a(s)$ to construct a sequence of $s$ values $S = \{s_0, s_1, s_2, \dots, s_n\}$ that meet our sampling criterion. We first construct the even samples (see Figures \ref{fig:conflict-resolution-even} and \ref{fig:conflict-resolution-adjacent-even}). Given a starting point $p(s_0)$,
\begin{equation}
p^x(s_{i+2}) = p^x(s_i) + a(s_i)
\end{equation}
Substituting in equations \eqref{eqn:p} and \eqref{eqn:ao}/\eqref{eqn:aa},
\begin{equation}
p_0^x + s_{i+2}u^x = p_0^x + s_i + \hat{\alpha} s_i + \hat{\beta}
\end{equation}
Solving for $s_{i+2}$ gives the recurrence relation
\begin{equation}
s_{i+2} = \alpha s_i + \beta \label{eqn:recurrence}
\end{equation}
where
\begin{equation}
\alpha = 1 + \frac{\hat{\alpha}}{u^x}
\end{equation}
and
\begin{equation}
\beta = \frac{\hat{\beta}}{u^x}
\end{equation}

Constructing the odd samples is identical, except that we start at
\begin{equation}
s_1 = \left(1+\frac{\hat{\alpha}}{2u^x}\right)s_0 + \frac{\hat{\beta}}{2}
\end{equation}
which is the point in the center of the first box in the x-dimension.

We solve the recurrence relation \eqref{eqn:recurrence} using the characteristic polynomial to yield
\begin{equation}
s_i = k_1 + k_2 \alpha^i
\end{equation}
where
\begin{align}
k_1^{even} &= \frac{\beta}{1-\alpha} \\
k_1^{odd} &= \frac{\beta}{1-\alpha} \\
k_2^{even} &= \frac{\alpha s_0 + \beta - s_0}{\alpha-1} \\
k_2^{odd} &= \frac{\alpha s_1 + \beta - s_1}{\alpha-1}
\end{align}
The last step to formulating $P$ for parallel computation is to determine how many samples we will need. Let $p(s_{exit})$ be the point at which the line $p$ exits the cell.
\begin{align}
k_1+k_2\alpha^i < s_{exit}
\end{align}
results in
\begin{align}
i < \log_{\alpha}\frac{s_{exit}-k_1}{k_2}
\end{align}

%
%. When $i$ is odd, the initial condition will be where $s$ is halfway along the first box (it could be anywhere in the interior of the first box, but we use halfway for convenience). So from \eqref{eqn:p},
%\begin{align}
%s_1 &= \frac{p^x-p_0^x}{2u^x} \\
%    &= \frac{a(0)}{2u^x}
%\end{align}
%\begin{align}
%k_1^{even} = k_1^{odd} &= \beta\left(1-\frac{\alpha}{\alpha-1}\right) \\
%k_2^{even} &= \frac{\beta}{\alpha-1} \\
%k_2^{odd} &= \frac{a(0)}{2u^x}+\frac{\beta}{\alpha-1}
%\end{align}
%
%It is tempting to formulate the recurrance relation using a single initial condition. This would be done by replacing equation \eqref{eqn:xi_init} with
%\begin{align}
%x_i &= x_{i-1} + \frac{a(s_{i-1})}{2}
%\end{align}
%This formulation can lead to conflict cells as shown in figure \ref{fig:conflict-resolution-half}.
%
%\begin{figure}
%  \centering
%  \includegraphics[width=0.48\columnwidth]{conflict-resolution-half.pdf}
%  \caption{Using a single recurrence solution we can no longer guarantee that every box that intersects both lines contains at least two samples. The box in red contains only one sample, so the quadtree may contain conflict cells.
%  }
%  \label{fig:conflict-resolution-half}
%\end{figure}



%With $a$ in hand, the question becomes, at what value of $s$ does $a(s)$ double? We desire to build a sequence $S=(s_0, s_1, \dots)$ such that $a(s_i) = 2a(s_{i-1})$. Substituting \eqref{eqn:p} into \eqref{eqn:a_prime} we get
%\begin{align}
%\label{eqn:klm}
%2a(s_{i-1}) &= \frac{q_0^xv^y-q_0^yv^x+(p_0^y+s_iu^y)v^x-(p_0^x+s_iu^x)v^y}{v^x+v^y} \nonumber \\
%&= \frac{q_0^xv^y-q_0^yv^x+p_0^yv^x-p_0^xv^y+s_i(u^yv^x-u^xv^y)}{v^x+v^y}
%\end{align}
%Solving for $s_i$ results in
%\begin{equation}
%\label{eqn:klm}
%s_i = \frac{2(v^x+v^y)a(s_{i-1})-q_0^xv^y+q_0^yv^x-p_0^yv^x+p_0^xv^y}{u^yv^x-u^xv^y}
%\end{equation}
%
%For $i>0$, $a(s_i)=a'(s_i)$, so we can characterize $s_i$ as a linear equation:
%\begin{align}
%s_0 &= 0 \nonumber \\
%s_1 &= 2ma(s_0)+b \nonumber \\
%s_2 &= 2^2ma(s_0)+b \nonumber \\
%\cdots \nonumber \\
%s_i &= 2^ima(s_0)+b
%\label{eqn:si}
%\end{align}
%where 
%\[m=\frac{v^x+v^y}{u^yv^x-u^xv^y}\]
%and
%\[b=\frac{-q_0^xv^y+q_0^yv^x-p_0^yv^x+p_0^xv^y}{u^yv^x-u^xv^y}\]
%%where $m=(v^x+v^y)/(u^yv^x-u^xv^y)$ and $b=(-q_0^xv^y+q_0^yv^x-p_0^yv^x+p_0^xv^y)/(u^yv^x-u^xv^y)$.
%
%The number of elements in sequence $S$ is obtained by setting equation \eqref{eqn:si} less than one and solving for $i$:
%\begin{equation}
%i < \log_2{\frac{1-b}{ma(s_0)}}
%\end{equation}

\subsection{Build quadtree on vertices}

We first construct an quadtree on the vertices of the objects, which we call the ``vertex quadtree''. We use Karras' algorithm \cite{karras2012maximizing} which sorts the Morton codes of the vertices in parallel, then constructs the binary radix tree in parallel. With the binary radix tree, the quadtree can be constructed with a single parallel call. The strength of this algorithm lies in the fact that overall performance scales linearly with the number of cores, regardless of the distribution of points. That is, even if a large number of vertices are clustered in a small area, requiring deep quadtree subdivision, only a constant number of parallel calls need be made. Given enough parallel units, the Karras algorithm runs in $O(\log{N})$ time, where $N$ is the number of vertices.

\subsection{Identify conflict cells}

Our end goal is to construct an quadtree such that no quadtree cell intersects more than one object. Note that a cell is allowed to intersect more than one facet, but all facets must belong to the same object, or, in other words, all facets must share the same label. It is possible, but unlikely, that the vertex quadtree has this property. If so, then we are done. Otherwise, we must identify subdivide conflict cells.

One naive algorithm to identify conflict cells is to process each leaf cell $c$ in parallel and store which facets intersect $c$. This is $O(N)$. Another approach is to process each facet in parallel and add it to every cell that it intersects. This is $O(k\log{N})$ where $k$ is maximum number of cells that any facet intersects. As we will show, our algorithm is $O(j + \log{N})$ where $j$ is the maximum number of facets that intersect any cell. In practice, $\log{N} > j$, making our algorithm $O(\log{N})$.

We identify conflict cells as shown in algorithm \ref{alg:find-conflict-cells}. In lines \ref{alg:quadtree_containing_begin}-\ref{alg:quadtree_containing_end}, for each internal quadtree cell $c$, we store all facets for which $c$ is the smallest containing cell. Since we are implementing this in a GPGPU environment, we don't have dynamic memory, so each facet must be processed twice. The first loop discovers how many facets are to be stored in each cell after which we allocate space for the facets. We use parallel prefix sums to determine the amount of space we need to allocate as well as the offsets for each internal cell. The second loop actually stores the facets.

The $\container{f}$ procedure finds the smallest quadtree cell that fully contains the facet $f$. A straightforward implementation of $\container{f}$ is to perform a standard quadtree search on the vertices of $f$ and take the smallest quadtree cell that contains all of them. (Note that the cell is always an internal node, since a post-condition of the Karras algorithm is that no leaf cell contains more than one vertex.) In our implementation however, we take advantage of our existing data structures. The quadtree cell that contains a vertex $v$ is uniquely determined by the D-tuple bits of its morton code. For example, if a 2D vertex has morton code $010010$, then the quadtree is traversed from the root to child $01$ to child $00$ to child $10$. To determine $\container{f}$, we find the longest common prefix (\lcp) of the vertices. Truncating the length of \lcp\,to a multiple of D, we find the smallest quadtree cell that contains all vertices of $f$. The complexity of $\container{f}$ is $O(\log{N})$ for both implementations. Thus, lines \ref{alg:quadtree_containing_begin}-\ref{alg:quadtree_containing_end} run in $O(\log{N})$ time.

Lines \ref{alg:quadtree_intersections_begin}-\ref{alg:quadtree_intersections_end} of the algorithm identify and store all facets that intersect with a given leaf cell $c$. Again, it is done in two steps for memory allocation purposes. Each leaf cell $c$ looks at its $O(\log{N})$ ancestors and tests all facets stored in those ancestors for intersection with $c$. Any intersecting facets get stored in $c$. These lines run in $O(F)$ time, where $F$ is the number of facets in all objects. Even though the loop is doubly-nested, each facet is stored in a unique internal node, so no more than $F$ facets will be visited in the loops. In practice, far fewer than $F$ facets will be checked for each leaf cell, because most datasets have facets that are completely contained in internal cells that are reasonably low in the tree.

The entire conflict cell detection algorithm runs in $O(\log{N}+L) = O(L)$ because $L > \log{N}$. However, average case is $O(\log{N})$, considering that most lines are contained entirely in a cell at reasonably low depth.

In Step 4, Stack is preallocated to size $M\cdot2^D$ where $M$ is the maximum quadtree depth and $D$ is the dimension. A conflict cell is a cell that intersects at least two different objects, or two lines of different labels.


The second procedure we use is $\directAncestors{c}$, which finds all ancestors of quadtree cell $c$.


%\SetKwFor{ForPar}{for}{do in parallel}{endfpar}

\algorithmspace
\begin{algorithm}
  \DontPrintSemicolon
  \LinesNumbered
  \KwIn{VertexQuadtree}
  \BlankLine
  \tcp{Store contained facets}
  \ForPar{facet $f$ in Objects}{
    \label{alg:quadtree_containing_begin}
    a := $\container{f}$\;
    a.numFacets := a.numFacets + 1\;
  }
  Allocate space for facets in internal cells\;
  \ForPar{facet $f$ in Objects}{
    a := $\container{f}$\;
    a.facets := a.facets $\cup$ f
  } \label{alg:quadtree_containing_end}
  \tcp{Store intersecting facets}
  \ForPar{leaf cell c in VertexQuadtree}{
    \label{alg:quadtree_intersections_begin}
    \ForEach{cell a in \directAncestors{c}}{
      \ForEach{facet $f$ in a.facets}{
        \If{$f$ intersects c}{
          c.numFacets := c.numFacets + 1\;
        }
      }
    }
  }
  Allocate space for facets in leaf cells\;
  \ForPar{leaf cell c in VertexQuadtree}{
    \ForEach{cell a in \directAncestors{c}}{
      \ForEach{facet $f$ in a.facets}{
        \If{$f$ intersects c}{
          c.facets := c.facets $\cup$ f\;
        }
      }
    }
  } \label{alg:quadtree_intersections_end}
\caption{FIND\_CONFLICT\_CELLS}
\label{alg:find-conflict-cells}
\end{algorithm}
\algorithmspace

\algorithmspace
\begin{algorithm}
  \DontPrintSemicolon
  \LinesNumbered
  \KwIn{Quadtree, conflict\_cells}
  \BlankLine
  \tcp{4. Quadtree refinement}
  \ForPar{leaf cell c in Quadtree}{
    c' := c\;
    \While{c' $\in$ conflict\_cells}{
      $(c'_0,c'_1,\dots,c'_{2^D-1})$ := subdivide c'\;
      push $(c'_0,c'_1,\dots,c'_{2^D-1})$ onto Stack\;
      c' := Stack.pop
    }
  }
\caption{REFINE\_QUADTREE}
\label{alg:refine-quadtree}
\end{algorithm}
\algorithmspace

\begin{figure}
  \centering
  \subfloat[][]{
    \label{fig:octree-cartesian-1}
    \includegraphics[width=0.24\columnwidth]{octree-cartesian-1.pdf} }
  \subfloat[][]{
    \label{fig:octree-cartesian-2}
    \includegraphics[width=0.24\columnwidth]{octree-cartesian-2.pdf} }
  \subfloat[][]{
    \label{fig:octree-cartesian-3}
    \includegraphics[width=0.24\columnwidth]{octree-cartesian-3.pdf} }
  \subfloat[][]{
    \label{fig:octree-cartesian-5}
    \includegraphics[width=0.24\columnwidth]{octree-cartesian-5.pdf} } \\
  \subfloat[][]{
    \label{fig:octree-hierarchical-1}
    \includegraphics[width=0.24\columnwidth]{octree-hierarchical-1.pdf} }
  \subfloat[][]{
    \label{fig:octree-hierarchical-2}
    \includegraphics[width=0.24\columnwidth]{octree-hierarchical-2.pdf} }
  \caption{
    \protect\subref{fig:octree-cartesian-1} A red object and a blue object.
    \protect\subref{fig:octree-cartesian-2} The vertex quadtree, or quadtree built on the object vertices using Karras' algorithm.
    \protect\subref{fig:octree-cartesian-3}, \protect\subref{fig:octree-hierarchical-1} The vertex quadtree with conflict cells highlighted. Note the label of an quadtree cell in \protect\subref{fig:octree-cartesian-3} is the concatenation of labels from root R to the leaf cell in \protect\subref{fig:octree-hierarchical-1}. This value also corresponds to the highest order bits of the morton code of any point in the cell.
    \protect\subref{fig:octree-cartesian-5}, \protect\subref{fig:octree-hierarchical-2} The quadtree after resolution of conflict cells.
  }
  \label{fig:steps}
\end{figure}

In Fig. \ref{fig:steps}, R (Root) is the smallest containing cell for lines A, B, and C, cell 20 contains line D, and cell 2 contains lines E and F. After Step 3 of the algorithm, line A is stored in leaf cells 202, 203, 21, and 3. Conflict cells, which are the only cells that are subdivided, are 203 and 21.

%\begin{table}
%  \centering
%  \begin{tabular}{ll}
%    \toprule
%    line &  $\container{line}$ \\
%    \midrule
%    A & R \\
%    B & R \\
%    C & R \\
%    D & 20 \\
%    E & 2 \\
%    F & 2 \\
%    \bottomrule
%  \end{tabular}
%\end{table}


%-----------------------------------------------------------
% Compute GVD surface
%-----------------------------------------------------------
\section{Compute GVD surface}
\label{sec:bisector}

%-------------------------------------------------------------------------------
% Results
%-------------------------------------------------------------------------------
\section{Results and applications}
Our implementation\footnote{Source code is available at \url{http://cedmav.org/research/project/33-gvds.html}.} of the algorithm supports \red{polygons and} triangulated objects, and our wavefront initialization step is implemented on the GPU using OpenCL. All tests were run on a MacBook Pro laptop with a dual-core 2.9 GHz processor, 8 GB memory, and Intel HD 4000 graphics card. Figure \ref{fig:bunny} shows our implementation of the GVD computation pipeline, and Figure \ref{fig:pipes} shows the computed GVD on a more challenging dataset.  We compare our method with other work and then show examples in three application settings: path planning, proximity queries, and exploded diagrams.

\subsection{Comparison to other methods}


% # quadtree vertices
%  52K ./viewer3 -l 8 ~/data/gears/gear[1-3].obj
% 170K ./viewer3 -l 12 ~/data/knife/knife-holder.obj ~/data/knife/knife[2-4].obj
% 146K ./viewer2 -l 24 ../data2/filled_ut/*.dat
% 2.8M ./viewer3 --uniform-colors -a 1 -l 8 ~/data/neuron/improved/a*.obj
% 1.3M ./viewer3 -l 8 ~/data/rice-dwarf/decimated2/n1UF2a-*.obj

% memory (54 bytes per quadtree cell)
%  2.8Mb ./viewer3 -l 8 ~/data/gears/gear[1-3].obj
%  9.2Mb ./viewer3 -l 12 ~/data/knife/knife-holder.obj ~/data/knife/knife[2-4].obj
% 7.9Mb ./viewer2 -l 24 ../data2/filled_ut/*.dat
% 151.2Mb ./viewer3 --uniform-colors -a 1 -l 8 ~/data/neuron/improved/a*.obj
% 70.2Mb ./viewer3 -l 8 ~/data/rice-dwarf/decimated2/n1UF2a-*.obj

\begin{table*}
  \centering
  \footnotesize{
  \begin{tabular}{l c c c c c c c}
    \toprule
    dataset & objects & object          & quadtree   & quadtree          & quadtree &
    GVD   & GVD             \\
            &         & $\Delta$s       & depth    & cells           & memory &
    (sec) & $\Delta$s       \\
            &         & ($\times 10^3$) &          & ($\times 10^3$) & (Mb)   &
          & ($\times 10^3$) \\
    \midrule
    % ./viewer3 -l 8 ~/data/gears/gear[1-3].obj
    Fig. \ref{fig:gears} & 3 & 7 & 8 & 54 & 3 & 0.9 & 83\\
    % ./viewer3 -l 12 ~/data/knife/knife-holder.obj ~/data/knife/knife[2-4].obj
    Fig. \ref{fig:knife} & 4 & 15 & 12 & 146 & 9 & 3.9 & 232 \\
    % ./viewer2 -l 24 ../data2/filled_ut/*.dat
    Fig. \ref{fig:path} & 470 & 5 & 24 & 158 & 8 & 2.0 & 151 \\
    % ./viewer3 --uniform-colors -a 1 -l 8 ~/data/neuron/improved/a*.obj
    Fig. \ref{fig:axons} & 448 & 4015 & 8 & 2716 & 151 & 195 & 8100 \\
    % ./viewer3 -l 8 ~/data/rice-dwarf/decimated2/n1UF2a-*.obj
    Fig. \ref{fig:mol-explode} & 35 & 1500 & 8 & 496 & 70 & 19 & 2700 \\
    \bottomrule
  \end{tabular}}
  \caption{Table of quadtree/GVD computation statistics and timings on datasets that are unmanageable using other methods. \red{Columns are: \emph{objects} - the number of objects in the dataset; \emph{object $\Delta$s} - the number of line segments (2D) or triangles (3D) of all objects in the dataset; \emph{quadtree depth} - required quadtree depth in order to resolve objects; \emph{quadtree cells} - total number of leaf quadtree cells; \emph{quadtree memory} - amount of memory used by the quadtree; \emph{GVD (sec)} - seconds to perform all steps of GVD computation; \emph{GVD $\Delta$s} - number of line segments (2D) or triangles (3D) in the GVD.}}
  \label{tab:timings}
\end{table*}


%-------------------------------------------------------------------------------
% Conclusions
%-------------------------------------------------------------------------------
\section{Conclusions}

%-------------------------------------------------------------------------------
% Acknowledgements
%-------------------------------------------------------------------------------
%\section*{Acknowledgements}
%Thanks to Kristen Harris for use of the neuronal data and Jonathan Bronson for the heart data. The work of JE and VP was supported in part by NSF IIS-1314896, NSF ACI-0904631, DOE/NEUP 120341, DOE/UV-CDAT DESC0006872, DOE/Codesign P01180734, DOE/SciDAC DESC0007446, DOE/PIPER DESC0010498, and DOE/CCMSC DENA0002375. This work initiated at the University of Texas when JE, ED  and CB were supported in part by NIH contract R01-EB00487, NSF Grant OCI-1216701 and SNL contract 1439100.

%-------------------------------------------------------------------------
% Bibliography
%-------------------------------------------------------------------------

%\bibliographystyle{eg-alpha}
\bibliographystyle{eg-alpha-doi}
\balance
\bibliography{paper}

\end{document}
