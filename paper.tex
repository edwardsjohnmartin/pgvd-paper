% ---------------------------------------------------------------------------
% Author guideline and sample document for EG publication using LaTeX2e input
% D.Fellner, v1.13, Jul 31, 2008

\documentclass{egpubl}
\usepackage{eg2015}

% --- for  Annual CONFERENCE
%\ConferenceSubmission   % uncomment for Conference submission
\ConferencePaper        % uncomment for (final) Conference Paper
% \STAR                   % uncomment for STAR contribution
% \Tutorial               % uncomment for Tutorial contribution
% \ShortPresentation      % uncomment for (final) Short Conference Presentation
% \Areas                  % uncomment for Areas contribution
% \MedicalPrize           % uncomment for Medical Prize contribution
% \Education              % uncomment for Education contribution
%
% --- for  CGF Journal
% \JournalSubmission    % uncomment for submission to Computer Graphics Forum
% \JournalPaper         % uncomment for final version of Journal Paper
%
% --- for  CGF Journal: special issue
% \SpecialIssueSubmission    % uncomment for submission to Computer Graphics Forum, special issue
% \SpecialIssuePaper         % uncomment for final version of Journal Paper, special issue
%
% --- for  EG Workshop Proceedings
% \WsSubmission    % uncomment for submission to EG Workshop
% \WsPaper         % uncomment for final version of EG Workshop contribution
%
 \electronicVersion % can be used both for the printed and electronic version

% !! *please* don't change anything above
% !! unless you REALLY know what you are doing
% ------------------------------------------------------------------------

% for including postscript figures
% mind: package option 'draft' will replace PS figure by a filname within a frame
%\ifpdf \usepackage[pdftex]{graphicx} \pdfcompresslevel=9
%\else \usepackage[dvips]{graphicx} \fi

\PrintedOrElectronic

% prepare for electronic version of your document
\usepackage{t1enc,dfadobe}

\usepackage{egweblnk}
\usepackage{cite}
\usepackage{balance}
\usepackage{color}

% For backwards compatibility to old LaTeX type font selection.
% Uncomment if your document adheres to LaTeX2e recommendations.
% \let\rm=\rmfamily    \let\sf=\sffamily    \let\tt=\ttfamily
% \let\it=\itshape     \let\sl=\slshape     \let\sc=\scshape
% \let\bf=\bfseries

% end of prologue

%\input{EGauthorGuidelines-body.inc}
% ---------------------------------------------------------------------
% EG author guidelines plus sample file for EG publication using LaTeX2e input
% D.Fellner, v1.17, Sep 23, 2010


\title[PGVD]%
      {Parallel Octree Construction on Collections of Objects}

% for anonymous conference submission please enter your SUBMISSION ID
% instead of the author's name (and leave the affiliation blank) !!
% For Computer Graphics Forum: Please use the abbreviation of your first name.

%% author example
%\author[D. Fellner \& S. Behnke]
%       {D.\,W. Fellner\thanks{Chairman Eurographics Publications Board}$^{1,2}$
%        and S. Behnke$^{2}$
%        S. Spencer$^2$\thanks{Chairman Siggraph Publications Board} \\
%         $^1$TU Darmstadt \& Fraunhofer IGD, Germany \\
%         $^2$Institut f{\"u}r ComputerGraphik \& Wissensvisualisierung, TU Graz, Austria
%       }

\author[J. Edwards \& N. Vollmer \& N. Harrison]
%       {John Edwards\thanks{jedwards@sci.utah.edu}$^1$ and
%       {John Edwards\\
       {John Edwards and
         Nathan Vollmer and
         Nicholas Harrison \\
         \parbox[t]{10cm}{\centering Idaho State University}
%         $^2$Google, Inc. \\
%         \footnotesize{$^3$The University of Texas at Austin}}
       }
%\author[paper1040]
%       {paper1040}

% ------------------------------------------------------------------------

% if the Editors-in-Chief have given you the data, you may uncomment
% the following five lines and insert it here
%
% \volume{27}   % the volume in which the issue will be published;
% \issue{1}     % the issue number of the publication
% \pStartPage{1}      % set starting page

\renewcommand{\paragraph}[1]{\noindent \textbf{#1}}
\input{common}

%-------------------------------------------------------------------------
\begin{document}

%\teaser{
%  \subfloat[][]{
%    \label{fig:gears1}
%    \begin{tikzpicture}
%      \node[anchor=south west,inner sep=0] at (0,0) {
%        \begin{tabular}[b]{c}
%          \includegraphics[height=0.8in]{gears-far1.png} \\
%          \includegraphics[height=0.8in]{gears-close1.png}
%        \end{tabular}
%      };
%      \draw[black,thick] (1.4,3.2) rectangle (2.0,3.6);
%      \draw[black,dashed] (1.4,3.6) -- (0.22,2.15);
%      \draw[black,dashed] (2.0,3.6) -- (2.95,2.15);
%      \draw[black,thick] (0.22,0.1) rectangle (2.95,2.15);
%    \end{tikzpicture}
%  }
%  \subfloat[][]{
%    \label{fig:gears}
%    \begin{tikzpicture}
%      \node[anchor=south west,inner sep=0] at (0,0) {
%        \begin{tabular}[b]{c}
%          \includegraphics[height=0.8in]{gears-far4.png} \\
%          \includegraphics[height=0.8in]{gears-close4.png}
%        \end{tabular}
%      };
%      \draw[black,thick] (1.3,3.1) rectangle (1.9,3.5);
%      \draw[black,dashed] (1.3,3.5) -- (0.22,2.15);
%      \draw[black,dashed] (1.9,3.5) -- (2.92,2.15);
%      \draw[black,thick] (0.22,0.1) rectangle (2.92,2.15);
%    \end{tikzpicture}
%  }
%  \hspace{3mm}
%  \subfloat[][]{
%    \label{fig:knife}
%    \includegraphics[trim=4cm 0cm 4cm 2.5cm, clip=true, height=1.4in]
%                    {knife-above/slice-00000.png}
%  }
%  \subfloat[][]{
%    \label{fig:knife2}
%    \includegraphics[trim=2mm 0cm 2mm 2cm, clip=true, height=1.4in]
%                    {knife-above/slice-00110.png}
%  }
%  \caption{Two example applications of the \red{approximated} generalized Voronoi diagram (GVD) computed by our novel, adaptive algorithm. Previous GVD methods require a gridded space of $2^{24}$ (gears dataset) and $2^{36}$ (knives dataset) voxels to resolve the closely spaced objects.
%    \protect\subref{fig:gears1} Two gears with regions of very tight spacing.
%    \protect\subref{fig:gears} The GVD of the gears model.  The surface is colored red in areas of very close tolerance.
%    \protect\subref{fig:knife} Three butter knives in a wood block.  To animate removal of the knives without intersecting the block requires extreme care because of close mesh spacing.
%    \protect\subref{fig:knife2} Intersection-free motion is guaranteed by computing motion vectors based on the GVD and allowing motion only within a Voronoi cell.
%  }
%  \label{fig:teaser}
%}
%
\maketitle

\begin{abstract}
We present a parallel octree algorithm that resolves between geometric objects. The octree has the property that no octree cell intersects more than one labeled object. Previous parallel algorithms either spawn kernels hierarchically, separate points only, or make no hard guarantees of object separation. Our algorithm runs in \red{complexity?} in the average case and has excellent results in practice. We demonstrate with results on 2D and 3D datasets.

%   Leave one blank line after the abstract, 
%   then add the subject categories according to the ACM Classification Index 
%   (see http://www.acm.org/class/1998/).

\begin{classification} % according to http://www.acm.org/class/1998/
  \CCScat{I.3.5}{Computer Graphics}{Computational Geometry and Object Modeling}{Boundary representations}
  \CCScat{I.3.6}{Computer Graphics}{Methodology and Techniques}{Graphics data structures and data types}
  %\CCScat{Computer Graphics}{I.3.3}{Picture/Image Generation}{Line and curve generation}
\end{classification}

\end{abstract}

%-------------------------------------------------------------------------
% Body
%-------------------------------------------------------------------------

%-------------------------------------------------------------------------------
% introduction
%-------------------------------------------------------------------------------
\section{Introduction}
\label{sec:intro}
Previous paper: \cite{edwards2015approximating}

The generalized Voronoi diagram (GVD) is an important structure that divides space into a complex of generalized Voronoi cells (GVCs) around objects.  Similar to the ordinary Voronoi diagram, each GVC contains exactly one object, or site, and every point in the GVC is closer to its contained object than to any other object.  The generalized Voronoi diagram is the boundary of the cell complex, and thus every point on the GVD is equidistant from two or more closest objects.  Applications of the GVD range from motion path planning to GIS analysis to mosaicking.

Ordinary Voronoi diagrams have been studied extensively and efficient algorithms exist to compute them, but the GVD is difficult to compute analytically in general \cite{boissonnat2006curved,hoff1999fast} and so the majority of approaches compute an approximation.  Whereas most algorithms are efficient and robust on certain datasets, all algorithms to our knowledge require inordinate amounts of memory on datasets where objects are very closely spaced relative to the size of the domain.  The failures occur because the space is uniformly gridded.  In such approaches, voxel size must be small enough to resolve object spacings, and if two objects are very close to each other the number of voxels can become prohibitively large.

We present an algorithm to compute a GVD approximation on arbitrary datasets, including those with closely spaced objects.  The approach applies a distance transform over an octree representation of the objects.  Our octree, its associated data structure, and our distance transform are novel and optimized to GVD approximation. For the remainder of the paper, ``GVD'' will refer to the approximated Generalized Voronoi Diagram.

This paper demonstrates GVD computation on data beyond the computational abilities of previous algorithms, unlocking interesting and important applications.  Our approach allows GVD-based proximity queries and other applications using a larger class of meaningful datasets.


Our algorithm has three steps:

\begin{enumerate}
\item Construct an octree on object vertices using Karras' algorithm \cite{karras2012maximizing}
\item Detect octree cells that intersect more than one object, which we call ``conflict cells'' (contribution)
\item Subdivide conflict cells to resolve objects (contribution)
\end{enumerate}

%-------------------------------------------------------------------------------
% Related work
%-------------------------------------------------------------------------------
\section{Related work}
Related work falls into two categories: algorithms that compute the GVD and algorithms that compute distance fields, many of which are adaptive.

\paragraph{Generalized Voronoi diagrams}
A theoretical framework for generalized Voronoi diagrams can be found in Boissonnat \etal \shortcite{boissonnat2006curved}. Ordinary Voronoi diagrams are well studied and efficient algorithms exist that compute them exactly \cite{de2008computational}, but exact algorithms for the generalized Voronoi diagram are limited to a small set of special cases \cite{lee1982medial,karavelas2004robust}. In an early work, Lavender \etal \shortcite{lavender1992voronoi} define and compute GVDs over a set of solid models using an octree.  Etzion and Rappoport \shortcite{etzion2002computing} represent the GVD bisector symbolically for lazy evaluation, but are limited to sites that are polyhedra.  Boada \etal \shortcite{boada2002voronoi,boada2008approximations} use an adaptive approach to GVD computation, but their algorithm is restricted to GVDs with connected regions and is inefficient for polyhedral objects with many facets.  Two other works are adaptive \cite{teichmann1997polygonal,vleugels1998approximating} but are computationally expensive and are restricted to convex sites.

In recent years Voronoi diagram algorithms that take advantage of fast graphics hardware have become more common \cite{cao2010parallel,fischer2006fast,hsieh2005simple,rong2007variants,sud2006interactive,sud2006fast,hoff1999fast,wu2008gpu}.  These algorithms are efficient and generalize well to the GVD, but most are limited to a subset of site types.  More importantly, all of them use uniform grids and require an extraordinary number of voxels to resolve closely spaced objects (for example, Figs. \ref{fig:knife} and \ref{fig:path} would require $2^{36}$ and $2^{48}$ voxels, respectively).  To our knowledge, ours is the first fully adaptive algorithm that computes the generalized Voronoi diagram for arbitrary datasets.

\paragraph{Distance fields and octrees}
The GVD is a subset of the locus of distance field critical points, a property that we take advantage of. In that light, the GVD could be a post-processing step to any method that computes a distance field.  Distance transforms compute a distance field, but most are uniformly gridded \cite{jones20063d} and are thus no more suitable than GVD algorithms that use the GPU.

% JME: note that in the Bastos work, ``reconstruction'' is reconstruction
% of the surface from the octree at rendering time.
Two seminal works adaptively compute the Adaptive Distance Field (ADF) on octree vertices.  Strain~\shortcite{strain1999fast} fully resolves the octree everywhere on the object surface, and Frisken \etal~\shortcite{frisken2000adaptively} resolve the octree fully only in areas of small local feature size.  Both approaches are designed to retain features of a single object rather than resolving between multiple objects, as is required for GVD computation.  Qu \etal \shortcite{qu2004feature} implement an energy-minimizing distance field algorithm that preserves features at the expense of efficiency.  Many recent works on fast octree construction using the GPU are limited to point sites \cite{bedorf2012sparse,karras2012maximizing,zhou2011data}. Most octree approaches that support surfaces \cite{baert2013out,crassin2009gigavoxels,laine2011efficient,lefebvre2007compressed} are designed for efficient rendering, and actual construction of the octree is implemented on the CPU.

Two works \cite{bastos2008gpu,park2010cuda} implement the ADF using GPU parallelism to compute the distance value at sample points, but building the octree itself is done sequentially.  Yin \etal~\shortcite{yin2011fast} compute the distance field entirely on the GPU using a bottom-up approach by initially subdividing into a complete octree, resulting in memory usage that is no better than using a uniform grid.  A method by Kim and Liu~\shortcite{kim2014exact} computes the octree and a BVH entirely on the GPU. However, octree construction is performed on barycenters of triangles, and so a leaf octree cell can have an arbitrary number of triangle intersections as long as it contains no more than one triangle's barycenter.  We have found no GPU octree construction method that can resolve between objects.

%-----------------------------------------------------------
% Build octree
%-----------------------------------------------------------
\section{Algorithm}
\label{sec:algorithm}
Our algorithm works in both 2D and 3D. Lacking a dimension-independent term, we use ``octree'' as a general term to refer to both quadtrees and octrees. We refer to object facets, which are lines in 2D and triangles in 3D.

\subsection{Resolving conflict cells}

%\begin{adjustbox}{valign=t}
\begin{figure}
  \centering
  \subfloat[][]{
    \label{fig:conflict-resolution-x}
    \includegraphics[width=0.48\columnwidth]{conflict-resolution-x.pdf} }
  \subfloat[][]{
    \label{fig:conflict-resolution-even}
    \includegraphics[width=0.48\columnwidth]{conflict-resolution-even.pdf} } \\
  \subfloat[][]{
    \label{fig:conflict-resolution-all}
    \includegraphics[width=0.48\columnwidth]{conflict-resolution-all.pdf} }
  \subfloat[][]{
    \label{fig:conflict-resolution-octree}
    \includegraphics[width=0.48\columnwidth]{conflict-resolution-octree-samples.pdf} }
  \caption{
    \protect\subref{fig:conflict-resolution-x} A conflict cell with two lines from different objects.
    \protect\subref{fig:conflict-resolution-even} Fitting boxes such that any box intersecting both lines contains at least one sample (red dots).
    \protect\subref{fig:conflict-resolution-even} Fitting boxes such that any box intersecting both lines contains at least two samples. This ensures that an octree built from the samples using Karras' algorithm (panel \protect\subref{fig:conflict-resolution-octree}) will have no leaf cells that intersect both lines, ensuring that the new octree is locally free of conflict cells.
  }
  \label{fig:conflict-resolution}
\end{figure}
%    \end{adjustbox}


%\begin{equation}
%\label{eqn:p}
%p(s) = p = p_0 + su
%\end{equation}
%\begin{equation}
%\label{eqn:q}
%q(s) = q = q_0 + tv
%\end{equation}
%\begin{equation}
%\label{eqn:a_}
%a(s) = a = |p^x-q^x| = |p^y-q^y|
%\end{equation}

To resolve conflict cells we consider pairs of lines of differing labels that intersect a cell $c$. Figure \ref{fig:conflict-resolution-x} shows two lines

\begin{align}
q(t) &= q = q_0 + tv \label{eqn:q} \\
r(f) &= r = r_0 + fw \label{eqn:r}
\end{align}
along with their bisector
\begin{align}
p(s) &= p = p_0 + su \label{eqn:p}
\end{align}
Our strategy will be to sample points $P$ on $p(u)$ (figure \ref{fig:conflict-resolution-octree}) such that an octree built on $V \cup P$ will completely ``separate'' $q$ and $r$, i.e., no descendent cell of $c$ will intersect both $q$ and $r$. We do this by ensuring that $P$ is sampled such that every box that intersects both $q$ and $r$ also intersects at least two points in $P$. Because Karras' algorithm guarantees that every leaf cell intersects at most one point, we know that no leaf cell will intersect $q$ and $r$ and thus no leaf cell will be a conflict cell.

We consider only bisecting lines with slope $0 \le m \le 1$. All other cases can be transformed to this case. We begin by fitting the smallest box centered at ??? that intersects both $q$ and $r$.

\subsubsection{Case $w^y>0$}

We wish to find $a = q^x-p^x$, which results in a box that touches both lines. Given a point $p$, we find $q$ by substituting in equations \eqref{eqn:q} and \eqref{eqn:r} and solving for $t$,
\begin{equation}
t = \frac{p^x+p^y-(q_0^x+q_0^y)}{v^x+v^y}
\end{equation}
Thus,
\begin{align} 
a(s) &= q^x(t) - p^x(s) \nonumber \\
   &= q_0^x + v^x\frac{p^x(s)+p^y(s)-(q_0^x+q_0^y)}{v^x+v^y} - p^x(s) \nonumber \\
%   &= \frac{q_0^xv^y-q_0^yv^x+p^yv^x-p^xv^y}{v^x+v^y} \nonumber \\
   &= \frac{q_0^xv^y-q_0^yv^x+p^y(s)v^x-p^x(s)v^y}{v^x+v^y} \nonumber \\
   &= \frac{q_0^xv^y-q_0^yv^x+p_0^yv^x-p_0^xv^y+s(u^yv^x-u^xv^y)}{v^x+v^y} \nonumber \\
   &= s\frac{u^yv^x-u^xv^y}{v^x+v^y}+\frac{q_0^xv^y-q_0^yv^x+p_0^yv^x-p_0^xv^y}{v^x+v^y} \label{eqn:a}
\end{align}

%$a$ is the largest power of two less than or equal to $a'$:
%\begin{equation}
%\label{eqn:ghi}
%a(s) = a = 2^{\lfloor \log_2{a'} \rfloor}
%\end{equation}


As shown in figure \ref{fig:conflict-resolution}, we desire to build a sequence $S=(s_0, s_1, \dots)$ such that $p^x(s_i) = p^x(s_{i-2}) + a(s_{i-2})$. %For convenience, we split the sequence into even and odd components and define $p^x(s_i) = p^x(s_{i-2}) + a(s_{i-2})$.
That is,
\begin{align}
x_i &= x_{i-2} + a(s_{i-2}) \label{eqn:xi_init}
\end{align}
Substituting in equation \eqref{eqn:a},
\begin{equation}
x_i = x_{i-2} + s_{i-2}\frac{u^yv^x-u^xv^y}{v^x+v^y} + \frac{q_0^xv^y-q_0^yv^x+p_0^yv^x-p_0^xv^y}{v^x+v^y}
\end{equation}
%\begin{align}
%x_i &= x_{i-1} + \frac{1}{v^x+v^y}(q_0^xv^y-q_0^yv^x+p^y(s_{i-1})v^x-p^x(s_{i-1})v^y)
%\end{align}
%Substituting in equation \eqref{eqn:p} and rearranging,
%\begin{align}
%x_i &= x_{i-1} + \frac{1}{v^x+v^y}(q_0^xv^y-q_0^yv^x+(p_0^y+s_{i-1}u^y)v^x-(p_0^x+s_{i-1}u^x)v^y) \\
%    &= x_{i-1} + \frac{1}{v^x+v^y}(q_0^xv^y-q_0^yv^x+p_0^yv^x-p_0^xv^y+s_{i-1}(u^yv^x-u^xv^y)) \\
%    &= x_{i-1} + s_{i-1}\frac{u^yv^x-u^xv^y}{v^x+v^y} + \frac{q_0^xv^y-q_0^yv^x+p_0^yv^x-p_0^xv^y}{v^x+v^y}
%\end{align}
Substituting in equation \eqref{eqn:p},
\begin{align}
x_i &= p_0^x+s_{i-2}u^x + s_{i-2}\frac{u^yv^x-u^xv^y}{v^x+v^y} + \frac{q_0^xv^y-q_0^yv^x+p_0^yv^x-p_0^xv^y}{v^x+v^y} \\
    &= s_{i-2}\frac{v^x(u^x+u^y)}{v^x+v^y} + \frac{q_0^xv^y-q_0^yv^x+p_0^yv^x+p_0^xv^x}{v^x+v^y} \label{eqn:xi}
\end{align}
We're now ready to build the sequence. From \eqref{eqn:p},
\begin{align}
s_i &= \frac{x_i-p_0^x}{u^x}
\end{align}
Substituting in equation \eqref{eqn:xi},
\begin{align}
s_i &= s_{i-2}\frac{v^x(u^x+u^y)}{u^x(v^x+v^y)} + \frac{q_0^xv^y-q_0^yv^x+p_0^yv^x-p_0^xv^y}{u^x(v^x+v^y)} \\
    &= \alpha s_{i-2} + \beta \label{eqn:si_rec}
\end{align}
where $\displaystyle \alpha=\frac{v^x(u^x+u^y)}{u^x(v^x+v^y)}$ and $\displaystyle \beta=\frac{q_0^xv^y-q_0^yv^x+p_0^yv^x-p_0^xv^y}{u^x(v^x+v^y)}$.

To solve the recurrence relation \eqref{eqn:si_rec},
\begin{align}
s_{i+2} &= \alpha s_i+\beta \\
s_{i+2}-s_i &= \alpha s_i-\alpha s_{i-2} \\
s_{i+2} &= (\alpha+1) s_i-\alpha s_{i-2}
\end{align}
The characteristic polynomial is
\begin{equation}
p(t) = t^2-(\alpha+1)t + \alpha
\end{equation}
which has roots $\alpha$ and $1$. Thus,
\begin{equation}
s_i = k_1 + k_2 \alpha^i
\end{equation}
The initial condition when $i$ is even is $s_0=0$. When $i$ is odd, the initial condition will be where $s$ is halfway along the first box (it could be anywhere in the interior of the first box, but we use halfway for convenience). So from \eqref{eqn:p},
\begin{align}
s_1 &= \frac{p^x-p_0^x}{2u^x} \\
    &= \frac{a(0)}{2u^x}
\end{align}
\begin{align}
k_1^{even} = k_1^{odd} &= \beta\left(1-\frac{\alpha}{\alpha-1}\right) \\
k_2^{even} &= \frac{\beta}{\alpha-1} \\
k_2^{odd} &= \frac{a(0)}{2u^x}+\frac{\beta}{\alpha-1}
\end{align}

It is tempting to formulate the recurrance relation using a single initial condition. This would be done by replacing equation \eqref{eqn:xi_init} with
\begin{align}
x_i &= x_{i-1} + \frac{a(s_{i-1})}{2}
\end{align}
This formulation can lead to conflict cells as shown in figure \ref{fig:conflict-resolution-half}.

\begin{figure}
  \centering
  \includegraphics[width=0.48\columnwidth]{conflict-resolution-half.pdf}
  \caption{Using a single recurrence solution we can no longer guarantee that every box that intersects both lines contains at least two samples. The box in red contains only one sample, so the octree may contain conflict cells.
  }
  \label{fig:conflict-resolution-half}
\end{figure}



%With $a$ in hand, the question becomes, at what value of $s$ does $a(s)$ double? We desire to build a sequence $S=(s_0, s_1, \dots)$ such that $a(s_i) = 2a(s_{i-1})$. Substituting \eqref{eqn:p} into \eqref{eqn:a_prime} we get
%\begin{align}
%\label{eqn:klm}
%2a(s_{i-1}) &= \frac{q_0^xv^y-q_0^yv^x+(p_0^y+s_iu^y)v^x-(p_0^x+s_iu^x)v^y}{v^x+v^y} \nonumber \\
%&= \frac{q_0^xv^y-q_0^yv^x+p_0^yv^x-p_0^xv^y+s_i(u^yv^x-u^xv^y)}{v^x+v^y}
%\end{align}
%Solving for $s_i$ results in
%\begin{equation}
%\label{eqn:klm}
%s_i = \frac{2(v^x+v^y)a(s_{i-1})-q_0^xv^y+q_0^yv^x-p_0^yv^x+p_0^xv^y}{u^yv^x-u^xv^y}
%\end{equation}
%
%For $i>0$, $a(s_i)=a'(s_i)$, so we can characterize $s_i$ as a linear equation:
%\begin{align}
%s_0 &= 0 \nonumber \\
%s_1 &= 2ma(s_0)+b \nonumber \\
%s_2 &= 2^2ma(s_0)+b \nonumber \\
%\cdots \nonumber \\
%s_i &= 2^ima(s_0)+b
%\label{eqn:si}
%\end{align}
%where 
%\[m=\frac{v^x+v^y}{u^yv^x-u^xv^y}\]
%and
%\[b=\frac{-q_0^xv^y+q_0^yv^x-p_0^yv^x+p_0^xv^y}{u^yv^x-u^xv^y}\]
%%where $m=(v^x+v^y)/(u^yv^x-u^xv^y)$ and $b=(-q_0^xv^y+q_0^yv^x-p_0^yv^x+p_0^xv^y)/(u^yv^x-u^xv^y)$.
%
%The number of elements in sequence $S$ is obtained by setting equation \eqref{eqn:si} less than one and solving for $i$:
%\begin{equation}
%i < \log_2{\frac{1-b}{ma(s_0)}}
%\end{equation}

\subsection{Build octree on vertices}

We first construct an octree on the vertices of the objects, which we call the ``vertex octree''. We use Karras' algorithm \cite{karras2012maximizing} which sorts the Morton codes of the vertices in parallel, then constructs the binary radix tree in parallel. With the binary radix tree, the octree can be constructed with a single parallel call. The strength of this algorithm lies in the fact that overall performance scales linearly with the number of cores, regardless of the distribution of points. That is, even if a large number of vertices are clustered in a small area, requiring deep octree subdivision, only a constant number of parallel calls need be made. Given enough parallel units, the Karras algorithm runs in $O(\log{N})$ time, where $N$ is the number of vertices.

\subsection{Identify conflict cells}

Our end goal is to construct an octree such that no octree cell intersects more than one object. Note that a cell is allowed to intersect more than one facet, but all facets must belong to the same object, or, in other words, all facets must share the same label. It is possible, but unlikely, that the vertex octree has this property. If so, then we are done. Otherwise, we must identify subdivide conflict cells.

One naive algorithm to identify conflict cells is to process each leaf cell $c$ in parallel and store which facets intersect $c$. This is $O(N)$. Another approach is to process each facet in parallel and add it to every cell that it intersects. This is $O(k\log{N})$ where $k$ is maximum number of cells that any facet intersects. As we will show, our algorithm is $O(j + \log{N})$ where $j$ is the maximum number of facets that intersect any cell. In practice, $\log{N} > j$, making our algorithm $O(\log{N})$.

We identify conflict cells as shown in algorithm \ref{alg:find-conflict-cells}. In lines \ref{alg:octree_containing_begin}-\ref{alg:octree_containing_end}, for each internal octree cell $c$, we store all facets for which $c$ is the smallest containing cell. Since we are implementing this in a GPGPU environment, we don't have dynamic memory, so each facet must be processed twice. The first loop discovers how many facets are to be stored in each cell after which we allocate space for the facets. We use parallel prefix sums to determine the amount of space we need to allocate as well as the offsets for each internal cell. The second loop actually stores the facets.

The $\container{f}$ procedure finds the smallest octree cell that fully contains the facet $f$. A straightforward implementation of $\container{f}$ is to perform a standard octree search on the vertices of $f$ and take the smallest octree cell that contains all of them. (Note that the cell is always an internal node, since a post-condition of the Karras algorithm is that no leaf cell contains more than one vertex.) In our implementation however, we take advantage of our existing data structures. The octree cell that contains a vertex $v$ is uniquely determined by the D-tuple bits of its morton code. For example, if a 2D vertex has morton code $010010$, then the octree is traversed from the root to child $01$ to child $00$ to child $10$. To determine $\container{f}$, we find the longest common prefix (\lcp) of the vertices. Truncating the length of \lcp\,to a multiple of D, we find the smallest octree cell that contains all vertices of $f$. The complexity of $\container{f}$ is $O(\log{N})$ for both implementations. Thus, lines \ref{alg:octree_containing_begin}-\ref{alg:octree_containing_end} run in $O(\log{N})$ time.

Lines \ref{alg:octree_intersections_begin}-\ref{alg:octree_intersections_end} of the algorithm identify and store all facets that intersect with a given leaf cell $c$. Again, it is done in two steps for memory allocation purposes. Each leaf cell $c$ looks at its $O(\log{N})$ ancestors and tests all facets stored in those ancestors for intersection with $c$. Any intersecting facets get stored in $c$. These lines run in $O(F)$ time, where $F$ is the number of facets in all objects. Even though the loop is doubly-nested, each facet is stored in a unique internal node, so no more than $F$ facets will be visited in the loops. In practice, far fewer than $F$ facets will be checked for each leaf cell, because most datasets have facets that are completely contained in internal cells that are reasonably low in the tree.

The entire conflict cell detection algorithm runs in $O(\log{N}+L) = O(L)$ because $L > \log{N}$. However, average case is $O(\log{N})$, considering that most lines are contained entirely in a cell at reasonably low depth.

In Step 4, Stack is preallocated to size $M\cdot2^D$ where $M$ is the maximum octree depth and $D$ is the dimension. A conflict cell is a cell that intersects at least two different objects, or two lines of different labels.


The second procedure we use is $\directAncestors{c}$, which finds all ancestors of octree cell $c$.


%\SetKwFor{ForPar}{for}{do in parallel}{endfpar}

\algorithmspace
\begin{algorithm}
  \DontPrintSemicolon
  \LinesNumbered
  \KwIn{VertexOctree}
  \BlankLine
  \tcp{Store contained facets}
  \ForPar{facet $f$ in Objects}{
    \label{alg:octree_containing_begin}
    a := $\container{f}$\;
    a.numFacets := a.numFacets + 1\;
  }
  Allocate space for facets in internal cells\;
  \ForPar{facet $f$ in Objects}{
    a := $\container{f}$\;
    a.facets := a.facets $\cup$ f
  } \label{alg:octree_containing_end}
  \tcp{Store intersecting facets}
  \ForPar{leaf cell c in VertexOctree}{
    \label{alg:octree_intersections_begin}
    \ForEach{cell a in \directAncestors{c}}{
      \ForEach{facet $f$ in a.facets}{
        \If{$f$ intersects c}{
          c.numFacets := c.numFacets + 1\;
        }
      }
    }
  }
  Allocate space for facets in leaf cells\;
  \ForPar{leaf cell c in VertexOctree}{
    \ForEach{cell a in \directAncestors{c}}{
      \ForEach{facet $f$ in a.facets}{
        \If{$f$ intersects c}{
          c.facets := c.facets $\cup$ f\;
        }
      }
    }
  } \label{alg:octree_intersections_end}
\caption{FIND\_CONFLICT\_CELLS}
\label{alg:find-conflict-cells}
\end{algorithm}
\algorithmspace

\algorithmspace
\begin{algorithm}
  \DontPrintSemicolon
  \LinesNumbered
  \KwIn{Octree, conflict\_cells}
  \BlankLine
  \tcp{4. Octree refinement}
  \ForPar{leaf cell c in Octree}{
    c' := c\;
    \While{c' $\in$ conflict\_cells}{
      $(c'_0,c'_1,\dots,c'_{2^D-1})$ := subdivide c'\;
      push $(c'_0,c'_1,\dots,c'_{2^D-1})$ onto Stack\;
      c' := Stack.pop
    }
  }
\caption{REFINE\_OCTREE}
\label{alg:refine-octree}
\end{algorithm}
\algorithmspace

\begin{figure}
  \centering
  \subfloat[][]{
    \label{fig:octree-cartesian-1}
    \includegraphics[width=0.48\columnwidth]{octree-cartesian-1.pdf} }
  \subfloat[][]{
    \label{fig:octree-cartesian-2}
    \includegraphics[width=0.48\columnwidth]{octree-cartesian-2.pdf} } \\
  \subfloat[][]{
    \label{fig:octree-cartesian-3}
    \includegraphics[width=0.48\columnwidth]{octree-cartesian-3.pdf} }
  \subfloat[][]{
    \label{fig:octree-cartesian-5}
    \includegraphics[width=0.48\columnwidth]{octree-cartesian-5.pdf} } \\
  \subfloat[][]{
    \label{fig:octree-hierarchical-1}
    \includegraphics[width=0.48\columnwidth]{octree-hierarchical-1.pdf} }
  \subfloat[][]{
    \label{fig:octree-hierarchical-2}
    \includegraphics[width=0.48\columnwidth]{octree-hierarchical-2.pdf} }
  \caption{
    \protect\subref{fig:octree-cartesian-1} A red object and a blue object.
    \protect\subref{fig:octree-cartesian-2} The vertex octree, or octree built on the object vertices using Karras' algorithm.
    \protect\subref{fig:octree-cartesian-3}, \protect\subref{fig:octree-hierarchical-1} The vertex octree with conflict cells highlighted. Note the label of an octree cell in \protect\subref{fig:octree-cartesian-3} is the concatenation of labels from root R to the leaf cell in \protect\subref{fig:octree-hierarchical-1}. This value also corresponds to the highest order bits of the morton code of any point in the cell.
    \protect\subref{fig:octree-cartesian-5}, \protect\subref{fig:octree-hierarchical-2} The octree after resolution of conflict cells.
  }
  \label{fig:steps}
\end{figure}

In Fig. \ref{fig:steps}, R (Root) is the smallest containing cell for lines A, B, and C, cell 20 contains line D, and cell 2 contains lines E and F. After Step 3 of the algorithm, line A is stored in leaf cells 202, 203, 21, and 3. Conflict cells, which are the only cells that are subdivided, are 203 and 21.

%\begin{table}
%  \centering
%  \begin{tabular}{ll}
%    \toprule
%    line &  $\container{line}$ \\
%    \midrule
%    A & R \\
%    B & R \\
%    C & R \\
%    D & 20 \\
%    E & 2 \\
%    F & 2 \\
%    \bottomrule
%  \end{tabular}
%\end{table}


%-----------------------------------------------------------
% Compute GVD surface
%-----------------------------------------------------------
\section{Compute GVD surface}
\label{sec:bisector}

%-------------------------------------------------------------------------------
% Results
%-------------------------------------------------------------------------------
\section{Results and applications}
Our implementation\footnote{Source code is available at \url{http://cedmav.org/research/project/33-gvds.html}.} of the algorithm supports \red{polygons and} triangulated objects, and our wavefront initialization step is implemented on the GPU using OpenCL. All tests were run on a MacBook Pro laptop with a dual-core 2.9 GHz processor, 8 GB memory, and Intel HD 4000 graphics card. Figure \ref{fig:bunny} shows our implementation of the GVD computation pipeline, and Figure \ref{fig:pipes} shows the computed GVD on a more challenging dataset.  We compare our method with other work and then show examples in three application settings: path planning, proximity queries, and exploded diagrams.

\subsection{Comparison to other methods}


% # octree vertices
%  52K ./viewer3 -l 8 ~/data/gears/gear[1-3].obj
% 170K ./viewer3 -l 12 ~/data/knife/knife-holder.obj ~/data/knife/knife[2-4].obj
% 146K ./viewer2 -l 24 ../data2/filled_ut/*.dat
% 2.8M ./viewer3 --uniform-colors -a 1 -l 8 ~/data/neuron/improved/a*.obj
% 1.3M ./viewer3 -l 8 ~/data/rice-dwarf/decimated2/n1UF2a-*.obj

% memory (54 bytes per octree cell)
%  2.8Mb ./viewer3 -l 8 ~/data/gears/gear[1-3].obj
%  9.2Mb ./viewer3 -l 12 ~/data/knife/knife-holder.obj ~/data/knife/knife[2-4].obj
% 7.9Mb ./viewer2 -l 24 ../data2/filled_ut/*.dat
% 151.2Mb ./viewer3 --uniform-colors -a 1 -l 8 ~/data/neuron/improved/a*.obj
% 70.2Mb ./viewer3 -l 8 ~/data/rice-dwarf/decimated2/n1UF2a-*.obj

\begin{table*}
  \centering
  \footnotesize{
  \begin{tabular}{l c c c c c c c}
    \toprule
    dataset & objects & object          & octree   & octree          & octree &
    GVD   & GVD             \\
            &         & $\Delta$s       & depth    & cells           & memory &
    (sec) & $\Delta$s       \\
            &         & ($\times 10^3$) &          & ($\times 10^3$) & (Mb)   &
          & ($\times 10^3$) \\
    \midrule
    % ./viewer3 -l 8 ~/data/gears/gear[1-3].obj
    Fig. \ref{fig:gears} & 3 & 7 & 8 & 54 & 3 & 0.9 & 83\\
    % ./viewer3 -l 12 ~/data/knife/knife-holder.obj ~/data/knife/knife[2-4].obj
    Fig. \ref{fig:knife} & 4 & 15 & 12 & 146 & 9 & 3.9 & 232 \\
    % ./viewer2 -l 24 ../data2/filled_ut/*.dat
    Fig. \ref{fig:path} & 470 & 5 & 24 & 158 & 8 & 2.0 & 151 \\
    % ./viewer3 --uniform-colors -a 1 -l 8 ~/data/neuron/improved/a*.obj
    Fig. \ref{fig:axons} & 448 & 4015 & 8 & 2716 & 151 & 195 & 8100 \\
    % ./viewer3 -l 8 ~/data/rice-dwarf/decimated2/n1UF2a-*.obj
    Fig. \ref{fig:mol-explode} & 35 & 1500 & 8 & 496 & 70 & 19 & 2700 \\
    \bottomrule
  \end{tabular}}
  \caption{Table of octree/GVD computation statistics and timings on datasets that are unmanageable using other methods. \red{Columns are: \emph{objects} - the number of objects in the dataset; \emph{object $\Delta$s} - the number of line segments (2D) or triangles (3D) of all objects in the dataset; \emph{octree depth} - required octree depth in order to resolve objects; \emph{octree cells} - total number of leaf octree cells; \emph{octree memory} - amount of memory used by the octree; \emph{GVD (sec)} - seconds to perform all steps of GVD computation; \emph{GVD $\Delta$s} - number of line segments (2D) or triangles (3D) in the GVD.}}
  \label{tab:timings}
\end{table*}


%-------------------------------------------------------------------------------
% Conclusions
%-------------------------------------------------------------------------------
\section{Conclusions}

%-------------------------------------------------------------------------------
% Acknowledgements
%-------------------------------------------------------------------------------
%\section*{Acknowledgements}
%Thanks to Kristen Harris for use of the neuronal data and Jonathan Bronson for the heart data. The work of JE and VP was supported in part by NSF IIS-1314896, NSF ACI-0904631, DOE/NEUP 120341, DOE/UV-CDAT DESC0006872, DOE/Codesign P01180734, DOE/SciDAC DESC0007446, DOE/PIPER DESC0010498, and DOE/CCMSC DENA0002375. This work initiated at the University of Texas when JE, ED  and CB were supported in part by NIH contract R01-EB00487, NSF Grant OCI-1216701 and SNL contract 1439100.

%-------------------------------------------------------------------------
% Bibliography
%-------------------------------------------------------------------------

%\bibliographystyle{eg-alpha}
\bibliographystyle{eg-alpha-doi}
\balance
\bibliography{paper}

\end{document}
